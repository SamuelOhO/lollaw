create sequence "public"."comments_id_seq";

create sequence "public"."likes_id_seq";

create sequence "public"."posts_id_seq";

-- drop policy "Anyone can view categories" on "public"."categories";

-- drop policy "Only admins can delete categories" on "public"."categories";

-- drop policy "Only admins can insert categories" on "public"."categories";

-- drop policy "Only admins can update categories" on "public"."categories";

-- drop policy "Views are updatable by authenticated users" on "public"."posts";

-- drop policy "Views are viewable by everyone" on "public"."posts";

-- alter table "public"."categories" drop constraint "categories_parent_id_fkey";

-- alter table "public"."posts" drop constraint "posts_user_id_fkey";

-- drop index if exists "public"."posts_views_idx";

create table "public"."comments" (
    "id" integer not null default nextval('comments_id_seq'::regclass),
    "content" text not null,
    "user_id" uuid not null,
    "post_id" integer not null,
    "created_at" timestamp with time zone default (now() AT TIME ZONE 'Asia/Seoul'::text),
    "updated_at" timestamp with time zone default (now() AT TIME ZONE 'Asia/Seoul'::text),
    "parent_id" integer,
    "report_count" integer default 0
);


alter table "public"."comments" enable row level security;

create table "public"."likes" (
    "id" integer not null default nextval('likes_id_seq'::regclass),
    "user_id" uuid,
    "post_id" integer,
    "created_at" timestamp with time zone default now()
);


alter table "public"."likes" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "display_name" text,
    "avatar_url" text,
    "created_at" timestamp with time zone not null default timezone('Asia/Seoul'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('Asia/Seoul'::text, now()),
    "nickname_last_updated" timestamp with time zone,
    "school_verified" boolean default false,
    "school_email" character varying,
    "school_document_url" character varying,
    "school_generation" integer,
    "lawyer_verified" boolean default false,
    "user_type" character varying default 'general'::character varying,
    "is_anonymous" boolean default false
);


alter table "public"."profiles" enable row level security;

create table "public"."reports" (
    "id" bigint generated by default as identity not null,
    "comment_id" bigint,
    "user_id" uuid,
    "reason" text not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."reports" enable row level security;

create table "public"."school_email_domains" (
    "id" bigint generated always as identity not null,
    "school_id" integer not null,
    "domain" text not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."school_email_domains" enable row level security;

alter table "public"."categories" add column "created_at" timestamp with time zone default (now() AT TIME ZONE 'Asia/Seoul'::text);

alter table "public"."posts" add column "category_id" integer not null;

alter table "public"."posts" add column "updated_at" timestamp with time zone default (now() AT TIME ZONE 'Asia/Seoul'::text);

alter table "public"."posts" alter column "content" set not null;

alter table "public"."posts" alter column "created_at" set default (now() AT TIME ZONE 'Asia/Seoul'::text);

alter table "public"."posts" alter column "id" set default nextval('posts_id_seq'::regclass);

alter table "public"."posts" alter column "id" set data type integer using "id"::integer;

alter table "public"."posts" alter column "user_id" set not null;

-- alter table "public"."posts" alter column "views" drop not null;

-- alter table "public"."school_verifications" drop column "school_name";

-- alter table "public"."school_verifications" drop column "verified";

alter table "public"."school_verifications" add column "email" text;

alter table "public"."school_verifications" add column "school_id" integer;

alter table "public"."school_verifications" add column "verification_code" text;

alter table "public"."school_verifications" add column "verification_method" text;

alter table "public"."school_verifications" alter column "id" set default uuid_generate_v4();

-- alter table "public"."school_verifications" alter column "status" drop default;

alter table "public"."school_verifications" alter column "verified_at" set default now();

alter sequence "public"."comments_id_seq" owned by "public"."comments"."id";

alter sequence "public"."likes_id_seq" owned by "public"."likes"."id";

alter sequence "public"."posts_id_seq" owned by "public"."posts"."id";

CREATE UNIQUE INDEX comments_pkey ON public.comments USING btree (id);

CREATE UNIQUE INDEX likes_pkey ON public.likes USING btree (id);

CREATE UNIQUE INDEX likes_user_id_post_id_key ON public.likes USING btree (user_id, post_id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX reports_comment_id_user_id_key ON public.reports USING btree (comment_id, user_id);

CREATE UNIQUE INDEX reports_pkey ON public.reports USING btree (id);

CREATE UNIQUE INDEX school_email_domains_pkey ON public.school_email_domains USING btree (id);

CREATE UNIQUE INDEX unique_school_domain ON public.school_email_domains USING btree (school_id, domain);

alter table "public"."comments" add constraint "comments_pkey" PRIMARY KEY using index "comments_pkey";

alter table "public"."likes" add constraint "likes_pkey" PRIMARY KEY using index "likes_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."reports" add constraint "reports_pkey" PRIMARY KEY using index "reports_pkey";

alter table "public"."school_email_domains" add constraint "school_email_domains_pkey" PRIMARY KEY using index "school_email_domains_pkey";

alter table "public"."comments" add constraint "comments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES comments(id) not valid;

alter table "public"."comments" validate constraint "comments_parent_id_fkey";

alter table "public"."comments" add constraint "comments_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) not valid;

alter table "public"."comments" validate constraint "comments_post_id_fkey";

alter table "public"."comments" add constraint "comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."comments" validate constraint "comments_user_id_fkey";

alter table "public"."likes" add constraint "likes_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."likes" validate constraint "likes_post_id_fkey";

alter table "public"."likes" add constraint "likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."likes" validate constraint "likes_user_id_fkey";

alter table "public"."likes" add constraint "likes_user_id_post_id_key" UNIQUE using index "likes_user_id_post_id_key";

alter table "public"."posts" add constraint "posts_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categories(id) not valid;

alter table "public"."posts" validate constraint "posts_category_id_fkey";

alter table "public"."posts" add constraint "posts_user_id_fkey1" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."posts" validate constraint "posts_user_id_fkey1";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_user_type_check" CHECK (((user_type)::text = ANY (ARRAY[('lawyer'::character varying)::text, ('law_student'::character varying)::text, ('general'::character varying)::text]))) not valid;

alter table "public"."profiles" validate constraint "profiles_user_type_check";

alter table "public"."reports" add constraint "reports_comment_id_fkey" FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE not valid;

alter table "public"."reports" validate constraint "reports_comment_id_fkey";

alter table "public"."reports" add constraint "reports_comment_id_user_id_key" UNIQUE using index "reports_comment_id_user_id_key";

alter table "public"."reports" add constraint "reports_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."reports" validate constraint "reports_user_id_fkey";

alter table "public"."school_email_domains" add constraint "school_email_domains_school_id_fkey" FOREIGN KEY (school_id) REFERENCES categories(id) not valid;

alter table "public"."school_email_domains" validate constraint "school_email_domains_school_id_fkey";

alter table "public"."school_email_domains" add constraint "unique_school_domain" UNIQUE using index "unique_school_domain";

alter table "public"."school_verifications" add constraint "school_verifications_school_id_fkey" FOREIGN KEY (school_id) REFERENCES categories(id) not valid;

alter table "public"."school_verifications" validate constraint "school_verifications_school_id_fkey";

alter table "public"."categories" add constraint "categories_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES categories(id) not valid;

alter table "public"."categories" validate constraint "categories_parent_id_fkey";

alter table "public"."posts" add constraint "posts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."posts" validate constraint "posts_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_school_verification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if not exists (
    select 1 
    from categories 
    where id = NEW.school_id 
    and parent_id = 2
    and requires_auth = true
  ) then
    raise exception 'Invalid school_id: must be a school category that requires authentication';
  end if;
  
  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles (id, display_name)
  values (new.id, split_part(new.email, '@', 1));
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_views(post_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE posts
  SET views = views + 1
  WHERE id = post_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_comment_report_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update comments
  set report_count = (
    select count(*)
    from reports
    where comment_id = new.comment_id
  )
  where id = new.comment_id;
  return new;
end;
$function$
;

grant delete on table "public"."comments" to "anon";

grant insert on table "public"."comments" to "anon";

grant references on table "public"."comments" to "anon";

grant select on table "public"."comments" to "anon";

grant trigger on table "public"."comments" to "anon";

grant truncate on table "public"."comments" to "anon";

grant update on table "public"."comments" to "anon";

grant delete on table "public"."comments" to "authenticated";

grant insert on table "public"."comments" to "authenticated";

grant references on table "public"."comments" to "authenticated";

grant select on table "public"."comments" to "authenticated";

grant trigger on table "public"."comments" to "authenticated";

grant truncate on table "public"."comments" to "authenticated";

grant update on table "public"."comments" to "authenticated";

grant delete on table "public"."comments" to "service_role";

grant insert on table "public"."comments" to "service_role";

grant references on table "public"."comments" to "service_role";

grant select on table "public"."comments" to "service_role";

grant trigger on table "public"."comments" to "service_role";

grant truncate on table "public"."comments" to "service_role";

grant update on table "public"."comments" to "service_role";

grant delete on table "public"."likes" to "anon";

grant insert on table "public"."likes" to "anon";

grant references on table "public"."likes" to "anon";

grant select on table "public"."likes" to "anon";

grant trigger on table "public"."likes" to "anon";

grant truncate on table "public"."likes" to "anon";

grant update on table "public"."likes" to "anon";

grant delete on table "public"."likes" to "authenticated";

grant insert on table "public"."likes" to "authenticated";

grant references on table "public"."likes" to "authenticated";

grant select on table "public"."likes" to "authenticated";

grant trigger on table "public"."likes" to "authenticated";

grant truncate on table "public"."likes" to "authenticated";

grant update on table "public"."likes" to "authenticated";

grant delete on table "public"."likes" to "service_role";

grant insert on table "public"."likes" to "service_role";

grant references on table "public"."likes" to "service_role";

grant select on table "public"."likes" to "service_role";

grant trigger on table "public"."likes" to "service_role";

grant truncate on table "public"."likes" to "service_role";

grant update on table "public"."likes" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."reports" to "anon";

grant insert on table "public"."reports" to "anon";

grant references on table "public"."reports" to "anon";

grant select on table "public"."reports" to "anon";

grant trigger on table "public"."reports" to "anon";

grant truncate on table "public"."reports" to "anon";

grant update on table "public"."reports" to "anon";

grant delete on table "public"."reports" to "authenticated";

grant insert on table "public"."reports" to "authenticated";

grant references on table "public"."reports" to "authenticated";

grant select on table "public"."reports" to "authenticated";

grant trigger on table "public"."reports" to "authenticated";

grant truncate on table "public"."reports" to "authenticated";

grant update on table "public"."reports" to "authenticated";

grant delete on table "public"."reports" to "service_role";

grant insert on table "public"."reports" to "service_role";

grant references on table "public"."reports" to "service_role";

grant select on table "public"."reports" to "service_role";

grant trigger on table "public"."reports" to "service_role";

grant truncate on table "public"."reports" to "service_role";

grant update on table "public"."reports" to "service_role";

grant delete on table "public"."school_email_domains" to "anon";

grant insert on table "public"."school_email_domains" to "anon";

grant references on table "public"."school_email_domains" to "anon";

grant select on table "public"."school_email_domains" to "anon";

grant trigger on table "public"."school_email_domains" to "anon";

grant truncate on table "public"."school_email_domains" to "anon";

grant update on table "public"."school_email_domains" to "anon";

grant delete on table "public"."school_email_domains" to "authenticated";

grant insert on table "public"."school_email_domains" to "authenticated";

grant references on table "public"."school_email_domains" to "authenticated";

grant select on table "public"."school_email_domains" to "authenticated";

grant trigger on table "public"."school_email_domains" to "authenticated";

grant truncate on table "public"."school_email_domains" to "authenticated";

grant update on table "public"."school_email_domains" to "authenticated";

grant delete on table "public"."school_email_domains" to "service_role";

grant insert on table "public"."school_email_domains" to "service_role";

grant references on table "public"."school_email_domains" to "service_role";

grant select on table "public"."school_email_domains" to "service_role";

grant trigger on table "public"."school_email_domains" to "service_role";

grant truncate on table "public"."school_email_domains" to "service_role";

grant update on table "public"."school_email_domains" to "service_role";

create policy "모든 사용자의 카테고리 조회 허용"
on "public"."categories"
as permissive
for select
to public
using (true);


create policy "인증된 사용자의 댓글 작성 허용"
on "public"."comments"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (auth.uid() = user_id)));


create policy "인증된 사용자의 학교게시판 댓글 조회 허용"
on "public"."comments"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM (posts
     JOIN categories ON ((categories.id = posts.category_id)))
  WHERE ((posts.id = comments.post_id) AND (categories.requires_auth = true))))));


create policy "자유게시판 댓글 조회 허용"
on "public"."comments"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM (posts
     JOIN categories ON ((categories.id = posts.category_id)))
  WHERE ((posts.id = comments.post_id) AND (categories.requires_auth = false)))));


create policy "작성자의 댓글 삭제 허용"
on "public"."comments"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "작성자의 댓글 수정 허용"
on "public"."comments"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Enable delete for post owners"
on "public"."likes"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Enable insert for authenticated users only"
on "public"."likes"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Enable read access for all users"
on "public"."likes"
as permissive
for select
to public
using (true);


create policy "로그인한 사용자만 좋아요 가능"
on "public"."likes"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "자신의 좋아요만 삭제 가능"
on "public"."likes"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "좋아요 조회 가능"
on "public"."likes"
as permissive
for select
to public
using (true);


create policy "인증된 사용자의 글 작성 허용"
on "public"."posts"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (auth.uid() = user_id)));


create policy "인증된 사용자의 학교게시판 글 조회 허용"
on "public"."posts"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM categories
  WHERE ((categories.id = posts.category_id) AND (categories.requires_auth = true))))));


create policy "자유게시판 글 조회 허용"
on "public"."posts"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM categories
  WHERE ((categories.id = posts.category_id) AND (categories.requires_auth = false)))));


create policy "작성자의 글 삭제 허용"
on "public"."posts"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "작성자의 글 수정 허용"
on "public"."posts"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "자신의 프로필만 수정 가능"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "프로필 조회 허용"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "로그인한 사용자만 신고 가능"
on "public"."reports"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "신고 조회 가능"
on "public"."reports"
as permissive
for select
to public
using (true);


create policy "Anyone can view school email domains"
on "public"."school_email_domains"
as permissive
for select
to authenticated
using (true);


create policy "Users can read their own verifications"
on "public"."school_verifications"
as permissive
for select
to public
using ((auth.uid() = user_id));


CREATE TRIGGER update_report_count AFTER INSERT OR DELETE ON public.reports FOR EACH ROW EXECUTE FUNCTION update_comment_report_count();

CREATE TRIGGER verify_school_category BEFORE INSERT OR UPDATE ON public.school_verifications FOR EACH ROW EXECUTE FUNCTION check_school_verification();


